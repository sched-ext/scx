/*
 * cosmos_wrapper.c - Wrapper to compile scx_cosmos as userspace C
 *
 * This file includes the simulator wrapper infrastructure and then
 * the actual scheduler source. The header guards in common.bpf.h
 * prevent re-inclusion, so our overridden macros take effect.
 *
 * NOTE: This file is compiled with -Dconst= to strip const qualifiers.
 * BPF schedulers declare globals as "const volatile" (patched by the
 * BPF loader). Stripping const makes them writable from Rust.
 */
#include "sim_wrapper.h"
#include "sim_task.h"

/*
 * COSMOS-specific macro overrides (defined after sim_wrapper.h,
 * before main.bpf.c).
 */

/*
 * Force scx_bpf_select_cpu_dfl fallback — avoids needing
 * scx_bpf_select_cpu_and which isn't implemented in the simulator.
 */
#undef bpf_ksym_exists
#define bpf_ksym_exists(sym) (0)

/*
 * The simulator always calls select_cpu before enqueue, so the
 * CPU is always selected.
 */
#undef __COMPAT_is_enq_cpu_selected
#define __COMPAT_is_enq_cpu_selected(enq_flags) (true)

/*
 * Simulated task_struct doesn't have migration_disabled field;
 * bpf_core_field_exists override would make the real function
 * try to access it.
 */
#undef is_migration_disabled
#define is_migration_disabled(p) ((void)(p), false)

/*
 * Route bpf_map_lookup_percpu_elem to a static cpu_ctx array.
 * Forward-declared here; defined after the scheduler source since
 * struct cpu_ctx is defined there.
 */
static struct cpu_ctx *cosmos_lookup_percpu_elem(int cpu);
#undef bpf_map_lookup_percpu_elem
#define bpf_map_lookup_percpu_elem(map, key, cpu) cosmos_lookup_percpu_elem(cpu)

/*
 * Perf disabled — stub out bpf_perf_event_read_value.
 */
#undef bpf_perf_event_read_value
#define bpf_perf_event_read_value(...) ((long)0)

/*
 * Include COSMOS interface header, then the scheduler source.
 * common.bpf.h is already included (header guard set), so our
 * BPF_STRUCT_OPS and SCX_OPS_DEFINE overrides are in effect.
 *
 * We include a patched copy of main.bpf.c (generated by config.mk)
 * that guards against division-by-zero in update_freq(). BPF
 * division-by-zero returns 0; native C crashes with SIGFPE.
 */
#include "intf.h"
#include "cosmos_main_patched.c"

/*
 * Static per-CPU context array, defined after the scheduler source
 * so that struct cpu_ctx is available.
 */
#define MAX_SIM_CPUS 128
static struct cpu_ctx percpu_ctx[MAX_SIM_CPUS];

static struct cpu_ctx *cosmos_lookup_percpu_elem(int cpu)
{
	if (cpu < 0 || cpu >= MAX_SIM_CPUS)
		return NULL;
	return &percpu_ctx[cpu];
}

/*
 * Register the COSMOS BPF maps with the test map infrastructure.
 *
 * Only task_ctx_stor (TASK_STORAGE) needs registration.
 * cpu_ctx_stor (PERCPU_ARRAY) is handled by the static array above.
 */
static struct scx_test_map task_ctx_map;

void cosmos_register_maps(void)
{
	INIT_SCX_TEST_MAP_FROM_TASK_STORAGE(&task_ctx_map, task_ctx_stor);
	scx_test_map_register(&task_ctx_map, &task_ctx_stor);
}

/*
 * Combined setup function called from Rust before cosmos_init().
 * Sets global variables to disable complex features, registers maps,
 * and enables CPU 0 in the primary domain.
 */
void cosmos_setup(unsigned int num_cpus)
{
	struct cpu_arg arg = { .cpu_id = 0 };

	smt_enabled = false;
	avoid_smt = false;
	primary_all = true;
	flat_idle_scan = false;
	preferred_idle_scan = false;
	cpufreq_enabled = false;
	numa_enabled = false;
	nr_node_ids = 1;
	mm_affinity = false;
	perf_enabled = false;
	deferred_wakeups = false;
	slice_ns = 20000000;   /* 20ms */
	slice_lag = 20000000;  /* 20ms */
	busy_threshold = 0;   /* always deadline mode */

	cosmos_register_maps();
	enable_primary_cpu(&arg);
}
