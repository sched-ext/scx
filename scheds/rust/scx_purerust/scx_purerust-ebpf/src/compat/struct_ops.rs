//! sched_ext struct_ops boilerplate: type definitions, callback
//! trampolines, and the ops map variable.
//!
//! HACK: All of this should be auto-generated by an aya struct_ops
//! procedural macro. The trampolines exist because BPF struct_ops
//! callbacks receive a context pointer in R1 (an array of u64 argument
//! values), not the declared callback parameters directly. Each
//! trampoline extracts arguments from the context and forwards them
//! to the clean callback in `crate::on_*`.
//!
//! The `sched_ext_ops` struct field names must match kernel BTF exactly.
//! Field types don't matter — the userspace BTF patcher replaces all
//! function pointer field types with PTR -> FUNC_PROTO.

use super::vmlinux::{scx_exit_info, task_struct};

// ── Callback type aliases ───────────────────────────────────────────────
//
// Generic function pointer types used for struct field declarations.
// The actual signatures don't matter for BTF (they get patched), but
// they must be pointer-sized so Option<T> uses null-pointer optimization.

type VoidCb = unsafe extern "C" fn(*const u64);
type I32Cb = unsafe extern "C" fn(*const u64) -> i32;
type InitCb = unsafe extern "C" fn() -> i32;

// ── sched_ext_ops ───────────────────────────────────────────────────────

/// Kernel `struct sched_ext_ops` — 34 callback fields + 6 data fields.
#[repr(C)]
pub struct sched_ext_ops {
    pub select_cpu: Option<I32Cb>,
    pub enqueue: Option<VoidCb>,
    pub dequeue: Option<VoidCb>,
    pub dispatch: Option<VoidCb>,
    pub tick: Option<VoidCb>,
    pub runnable: Option<VoidCb>,
    pub running: Option<VoidCb>,
    pub stopping: Option<VoidCb>,
    pub quiescent: Option<VoidCb>,
    pub r#yield: Option<VoidCb>,
    pub core_sched_before: Option<VoidCb>,
    pub set_weight: Option<VoidCb>,
    pub set_cpumask: Option<VoidCb>,
    pub update_idle: Option<VoidCb>,
    pub cpu_acquire: Option<VoidCb>,
    pub cpu_release: Option<VoidCb>,
    pub init_task: Option<I32Cb>,
    pub exit_task: Option<VoidCb>,
    pub enable: Option<VoidCb>,
    pub disable: Option<VoidCb>,
    pub dump: Option<VoidCb>,
    pub dump_cpu: Option<VoidCb>,
    pub dump_task: Option<VoidCb>,
    pub cgroup_init: Option<I32Cb>,
    pub cgroup_exit: Option<VoidCb>,
    pub cgroup_prep_move: Option<I32Cb>,
    pub cgroup_move: Option<VoidCb>,
    pub cgroup_cancel_move: Option<VoidCb>,
    pub cgroup_set_weight: Option<VoidCb>,
    pub cgroup_set_bandwidth: Option<VoidCb>,
    pub cpu_online: Option<VoidCb>,
    pub cpu_offline: Option<VoidCb>,
    pub init: Option<InitCb>,
    pub exit: Option<VoidCb>,
    // Data fields
    pub dispatch_max_batch: u32,
    pub flags: u64,
    pub timeout_ms: u32,
    pub exit_dump_len: u32,
    pub hotplug_seq: u64,
    pub name: [u8; 128],
}

// ── Callback trampolines ────────────────────────────────────────────────
//
// Each trampoline is placed in a `struct_ops/` ELF section so libbpf
// recognizes it as a struct_ops BPF program. The first parameter
// captures R1 (the BPF context pointer). We cast it to `*const u64`
// and read callback arguments from the context array.
//
// The BPF verifier uses the *kernel* BTF callback signature (not ours)
// to type-check context accesses, so our parameter types don't affect
// verification.

#[unsafe(no_mangle)]
#[unsafe(link_section = "struct_ops/simple_select_cpu")]
unsafe extern "C" fn simple_select_cpu(ctx: *const u64) -> i32 {
    let p = unsafe { *ctx as *mut task_struct };
    let prev_cpu = unsafe { *ctx.add(1) as i32 };
    let wake_flags = unsafe { *ctx.add(2) };
    crate::on_select_cpu(p, prev_cpu, wake_flags)
}

#[unsafe(no_mangle)]
#[unsafe(link_section = "struct_ops/simple_enqueue")]
unsafe extern "C" fn simple_enqueue(ctx: *const u64) {
    let p = unsafe { *ctx as *mut task_struct };
    let enq_flags = unsafe { *ctx.add(1) };
    crate::on_enqueue(p, enq_flags);
}

#[unsafe(no_mangle)]
#[unsafe(link_section = "struct_ops/simple_dispatch")]
unsafe extern "C" fn simple_dispatch(ctx: *const u64) {
    let cpu = unsafe { *ctx as i32 };
    let prev = unsafe { *ctx.add(1) as *mut task_struct };
    crate::on_dispatch(cpu, prev);
}

#[unsafe(no_mangle)]
#[unsafe(link_section = "struct_ops/simple_running")]
unsafe extern "C" fn simple_running(ctx: *const u64) {
    let p = unsafe { *ctx as *mut task_struct };
    crate::on_running(p);
}

#[unsafe(no_mangle)]
#[unsafe(link_section = "struct_ops/simple_stopping")]
unsafe extern "C" fn simple_stopping(ctx: *const u64) {
    let p = unsafe { *ctx as *mut task_struct };
    let runnable = unsafe { *ctx.add(1) != 0 };
    crate::on_stopping(p, runnable);
}

#[unsafe(no_mangle)]
#[unsafe(link_section = "struct_ops/simple_enable")]
unsafe extern "C" fn simple_enable(ctx: *const u64) {
    let p = unsafe { *ctx as *mut task_struct };
    crate::on_enable(p);
}

#[unsafe(no_mangle)]
#[unsafe(link_section = "struct_ops.s/simple_init")]
unsafe extern "C" fn simple_init() -> i32 {
    crate::on_init()
}

#[unsafe(no_mangle)]
#[unsafe(link_section = "struct_ops/simple_exit")]
unsafe extern "C" fn simple_exit(ctx: *const u64) {
    let ei = unsafe { *ctx as *mut scx_exit_info };
    crate::on_exit(ei);
}

// ── Ops map ─────────────────────────────────────────────────────────────

const fn make_name() -> [u8; 128] {
    let mut name = [0u8; 128];
    let src = b"purerust";
    let mut i = 0;
    while i < src.len() {
        name[i] = src[i];
        i += 1;
    }
    name
}

/// The struct_ops map. Placed in `.struct_ops.link` so libbpf auto-attaches it.
/// `Some(fn)` values generate ELF relocations that libbpf uses to map
/// struct fields to BPF programs. `None` means the callback is not implemented.
#[unsafe(link_section = ".struct_ops.link")]
#[unsafe(no_mangle)]
static simple_ops: sched_ext_ops = sched_ext_ops {
    select_cpu: Some(simple_select_cpu),
    enqueue: Some(simple_enqueue),
    dequeue: None,
    dispatch: Some(simple_dispatch),
    tick: None,
    runnable: None,
    running: Some(simple_running),
    stopping: Some(simple_stopping),
    quiescent: None,
    r#yield: None,
    core_sched_before: None,
    set_weight: None,
    set_cpumask: None,
    update_idle: None,
    cpu_acquire: None,
    cpu_release: None,
    init_task: None,
    exit_task: None,
    enable: Some(simple_enable),
    disable: None,
    dump: None,
    dump_cpu: None,
    dump_task: None,
    cgroup_init: None,
    cgroup_exit: None,
    cgroup_prep_move: None,
    cgroup_move: None,
    cgroup_cancel_move: None,
    cgroup_set_weight: None,
    cgroup_set_bandwidth: None,
    cpu_online: None,
    cpu_offline: None,
    init: Some(simple_init),
    exit: Some(simple_exit),
    dispatch_max_batch: 0,
    flags: 0,
    timeout_ms: 0,
    exit_dump_len: 0,
    hotplug_seq: 0,
    name: make_name(),
};
